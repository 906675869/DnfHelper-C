#include "pch.h"
#include "stdlib.h"
#include "寻路.h"

#include "Address.h"
#include "读写.h"
#include "判断.h"
#include "游戏Call.h"
#include "组包.h"
#include "数组.h"
#include "公告.h"
#include "引用.h"


地图型 获取数据()
{
	地图型 游戏地图;
	ULONG64 地图指针 = NULL;
	ULONG64 宽高地址 = NULL;
	ULONG64 通道地址 = NULL;

	地图指针 = 地图Call(收包.参_地图编号);

	宽高地址 = *(ULONG64*)(地图指针 + 宽高偏移);

	游戏地图.宽度 = *(ULONG*)(宽高地址 + 收包.参_地图序号 * 8 + 0);
	游戏地图.高度 = *(ULONG*)(宽高地址 + 收包.参_地图序号 * 8 + 4);

	游戏地图.起始.x = 收包.参_当前坐标.x + 1;
	游戏地图.起始.y = 收包.参_当前坐标.y + 1;
	游戏地图.终点.x = 收包.参_领主坐标.x + 1;
	游戏地图.终点.y = 收包.参_领主坐标.y + 1;


	神话公告(L"游戏地图.起始.x: " + 到文本(收包.参_当前坐标.x + 1), 1);
	神话公告(L"游戏地图.起始.y: " + 到文本(收包.参_当前坐标.y + 1), 1);
	神话公告(L"游戏地图.终点.x: " + 到文本(收包.参_领主坐标.x + 1), 1);
	神话公告(L"游戏地图.终点.y: " + 到文本(收包.参_领主坐标.y + 1), 1);

	通道地址 = *(ULONG64*)(地图指针 + 数组偏移) + 32;

	通道地址 = *(ULONG64*)(通道地址 + 收包.参_地图序号 * (数组偏移 - 宽高偏移) + 8);

	int 通道数量 = 游戏地图.宽度 * 游戏地图.高度;

	for (size_t i = 0; i < 通道数量; i++)
	{
		游戏地图.通道.push_back(*(ULONG*)(通道地址 + i * 4));
	}

	if (通道数量 > 1)
	{
		游戏地图.消耗 = 获取走法(游戏地图.通道, 游戏地图.宽度, 游戏地图.高度, 游戏地图.起始, 游戏地图.终点, 游戏地图.走法);
	}

	return 游戏地图;
}




int 获取走法(vector<int> 地图通道, int 地图宽度, int 地图高度, 坐标型 起点坐标, 坐标型 终点坐标, vector<坐标型>& 真实走法)
{
	坐标型 起始坐标;
	坐标型 结束坐标;
	vector<vector<路线型>> 标签数组;
	vector<vector<路线型>> 地图数组;
	vector<坐标型> 走法数组;

	if (起点坐标.x == 终点坐标.x && 起点坐标.y == 终点坐标.y)
	{
		真实走法.clear();
		真实走法.resize(0);
		return 0;
	}

	生成地图(地图宽度, 地图高度, 地图通道, 地图数组);

	显示地图(地图数组, 地图宽度, 地图高度, 标签数组);

	起始坐标.x = 起点坐标.x * 3 - 2;
	起始坐标.y = 起点坐标.y * 3 - 2;
	结束坐标.x = 终点坐标.x * 3 - 2;
	结束坐标.y = 终点坐标.y * 3 - 2;

	路径算法(标签数组, 起始坐标, 结束坐标, 地图宽度 * 3, 地图高度 * 3, 走法数组);

	return 整理坐标(走法数组, 真实走法);
}

void 生成地图(int 地图宽度, int 地图高度, vector<int> 地图通道, vector<vector<路线型>>& 地图路线)
{
	地图路线.clear();

	地图路线.resize(地图宽度);

	for (int x = 0; x < 地图宽度; x++)
	{
		地图路线[x].resize(地图高度);
	}

	int i = 0;

	for (int y = 0; y < 地图高度; y++)
	{
		for (int x = 0; x < 地图宽度; x++)
		{
			地图路线[x][y].坐标.x = x;
			地图路线[x][y].坐标.y = y;
			地图路线[x][y].通道 = 地图通道[i];
			地图路线[x][y].左边 = 方向判断(地图通道[i], 0);
			地图路线[x][y].右边 = 方向判断(地图通道[i], 1);
			地图路线[x][y].上边 = 方向判断(地图通道[i], 2);
			地图路线[x][y].下边 = 方向判断(地图通道[i], 3);
			地图路线[x][y].颜色 = 0xFFFFFF;
			i++;
			if (地图路线[x][y].通道 == 0)
			{
				地图路线[x][y].颜色 = 0x000000;
			}

		}
	}
}


void 路径算法(vector<vector<路线型>> 地图标签, 坐标型 地图起点, 坐标型 地图终点, int 地图宽度, int 地图高度, vector<坐标型>& 走法数组)
{
	坐标型 待检测坐标;

	int x, y;

	int 最短编号 = 0;

	int 最小F_值, 预测G_值;

	节点型 待检测节点, 临时节点;

	vector<节点型> 开放列表, 关闭列表;

	bool 已存在开放列表, 已存在关闭列表;

	临时节点.当前.x = 地图起点.x;
	临时节点.当前.y = 地图起点.y;

	地图标签[地图起点.x][地图起点.y].颜色 = 0x00FF00;
	地图标签[地图终点.x][地图终点.y].颜色 = 0x0000FF;

	开放列表.insert(开放列表.begin(), 临时节点);
	do
	{
		最小F_值 = 0;

		for (y = 0; y < 开放列表.size(); y++)
		{
			if (最小F_值 == 0)
			{
				最小F_值 = 开放列表[0].F_点;
				最短编号 = y;
			}
			if (开放列表[y].F_点 < 最小F_值)
			{
				最小F_值 = 开放列表[y].F_点;
				最短编号 = y;
			}
		}

		临时节点 = 开放列表[最短编号];

		开放列表.erase(开放列表.begin() + 最短编号);
		关闭列表.insert(关闭列表.begin(), 临时节点);

		if (临时节点.当前.x != 地图起点.x || 临时节点.当前.y != 地图起点.y)
		{
			if (临时节点.当前.x != 地图终点.x || 临时节点.当前.y != 地图终点.y)
			{
				地图标签[临时节点.当前.x][临时节点.当前.y].颜色 = 0x0080FF;
			}
		}

		for (y = 0; y < 关闭列表.size(); y++)
		{
			if (关闭列表[y].当前.x == 地图终点.x && 关闭列表[y].当前.y == 地图终点.y)
			{
				待检测节点 = 关闭列表[y];
				do
				{
					for (int x = 0; x < 关闭列表.size(); x++)
					{
						if (关闭列表[x].当前.x == 待检测节点.最终.x && 关闭列表[x].当前.y == 待检测节点.最终.y)
						{
							待检测节点 = 关闭列表[x];
							break;
						}
					}
					if (待检测节点.当前.x != 地图起点.x || 待检测节点.当前.y != 地图起点.y)
					{
						地图标签[待检测节点.当前.x][待检测节点.当前.y].颜色 = 0x00D8D8;
						走法数组.insert(走法数组.begin(), 待检测节点.当前);
					}
				} while (待检测节点.当前.x != 地图起点.x || 待检测节点.当前.y != 地图起点.y);

				走法数组.insert(走法数组.begin(), 地图起点);
				走法数组.insert(走法数组.end(), 地图终点);

				return;
			}
		}
		for (y = 0; y < 4; y++)
		{
			if (y == 0)
			{
				待检测坐标.x = 临时节点.当前.x;
				待检测坐标.y = 临时节点.当前.y - 1;
			}
			else if (y == 1)
			{
				待检测坐标.x = 临时节点.当前.x - 1;
				待检测坐标.y = 临时节点.当前.y;
			}
			else if (y == 2)
			{
				待检测坐标.x = 临时节点.当前.x + 1;
				待检测坐标.y = 临时节点.当前.y;
			}
			else
			{
				待检测坐标.x = 临时节点.当前.x;
				待检测坐标.y = 临时节点.当前.y + 1;
			}

			if (待检测坐标.x < 0 || 待检测坐标.x >(地图宽度 - 1) || 待检测坐标.y < 0 || 待检测坐标.y >(地图高度 - 1))
			{
				continue;
			}

			if (地图标签[待检测坐标.x][待检测坐标.y].颜色 == 0x000000)
			{
				continue;
			}

			已存在关闭列表 = false;

			for (x = 0; x < 关闭列表.size(); x++)
			{
				if (关闭列表[x].当前.x == 待检测坐标.x && 关闭列表[x].当前.y == 待检测坐标.y)
				{
					已存在关闭列表 = true;
					break;
				}
			}

			if (已存在关闭列表)
			{
				continue;
			}

			已存在开放列表 = false;

			for (x = 0; x < 开放列表.size(); x++)
			{
				if (开放列表[x].当前.x == 待检测坐标.x && 开放列表[x].当前.y == 待检测坐标.y)
				{
					if (待检测坐标.x != 临时节点.当前.x || 待检测坐标.y != 临时节点.当前.y)
					{
						预测G_值 = 14;
					}
					else
					{
						预测G_值 = 10;
					}
					if (临时节点.G_点 + 预测G_值 < 开放列表[x].G_点)
					{
						开放列表[x].最终 = 临时节点.当前;
					}

					已存在开放列表 = true;

					break;
				}
			}

			if (已存在开放列表 == false)
			{
				if (待检测坐标.x == 临时节点.当前.x || 待检测坐标.y == 临时节点.当前.y)
				{
					预测G_值 = 10;
				}
				else
				{
					预测G_值 = 14;
				}

				待检测节点.G_点 = 临时节点.G_点 + 预测G_值;

				待检测节点.H_点 = abs(FLOAT(地图终点.x - 待检测坐标.x)) * 10 + abs(FLOAT(地图终点.y - 待检测坐标.y)) * 10;

				待检测节点.F_点 = 待检测节点.G_点 + 待检测节点.H_点;

				待检测节点.当前 = 待检测坐标;

				待检测节点.最终 = 临时节点.当前;

				开放列表.insert(开放列表.begin(), 待检测节点);

			}
		}
	} while (开放列表.size() != 0);
}


void 显示地图(vector<vector<路线型>> 地图数组, int 地图宽度, int 地图高度, vector<vector<路线型>>& 地图标签)
{
	地图标签.clear();

	地图标签.resize(地图宽度 * 3);

	for (int x = 0; x < 地图宽度 * 3; x++)
	{
		地图标签[x].resize(地图高度 * 3);
	}

	for (int y = 0; y < 地图高度; y++)
	{
		for (int x = 0; x < 地图宽度; x++)
		{
			地图标签[(x + 1) * 3 - 2][(y + 1) * 3 - 2].颜色 = 0xFFFFFF;

			if (地图数组[x][y].左边)
			{
				地图标签[(x + 1) * 3 - 3][(y + 1) * 3 - 2].颜色 = 0xFFFFFF;
			}
			if (地图数组[x][y].右边)
			{
				地图标签[(x + 1) * 3 - 1][(y + 1) * 3 - 2].颜色 = 0xFFFFFF;
			}
			if (地图数组[x][y].上边)
			{
				地图标签[(x + 1) * 3 - 2][(y + 1) * 3 - 3].颜色 = 0xFFFFFF;
			}
			if (地图数组[x][y].下边)
			{
				地图标签[(x + 1) * 3 - 2][(y + 1) * 3 - 1].颜色 = 0xFFFFFF;
			}
		}
	}
}



int 整理坐标(vector<坐标型> 模拟走法, vector<坐标型>& 真实走法)
{
	int x, y;
	int k = 0;
	坐标型 临时坐标;
	for (int i = 0; i < 模拟走法.size(); i++)
	{
		x = (模拟走法[i].x + 2) % 3;
		y = (模拟走法[i].y + 2) % 3;
		if (x == 0 && y == 0)
		{
			临时坐标.x = (模拟走法[i].x + 2) / 3 - 1;
			临时坐标.y = (模拟走法[i].y + 2) / 3 - 1;
			真实走法.insert(真实走法.begin() + k, 临时坐标);
			k++;
		}
	}
	return(k);
}

bool 方向判断(int 通向, int 方向)
{
	unsigned char 方向数组[4];
	unsigned char 方向集合[16][4] = { { 0, 0, 0, 0 },{ 0, 1, 0, 0 },{ 0, 0, 1, 0 },{ 0, 1, 1, 0 },{ 1, 0, 0, 0 },{ 1, 1, 0, 0 },{ 1, 0, 1, 0 },{ 1, 1, 1, 0 },
	{ 0, 0, 0, 1 },{ 0, 1, 0, 1 },{ 0, 0, 1, 1 },{ 0, 1, 1, 1 },{ 1, 0, 0, 1 },{ 1, 1, 0, 1 },{ 1, 0, 1, 1 },{ 1, 1, 1, 1 } };

	if (通向 >= 0 && 通向 <= 15)
	{
		for (int i = 0; i < 4; i++)
		{
			方向数组[i] = 方向集合[通向][i];
		}
	}
	else
	{
		for (int i = 0; i < 4; i++)
		{
			方向数组[i] = 0;
		}
	}

	if (方向数组[方向] == 1)
	{
		return true;
	}
	else
	{
		return false;
	}
}

int 计算方向(坐标型 当前, 坐标型 下个)
{

	int x, y;
	int result = -1;

	x = 当前.x - 下个.x;
	y = 当前.y - 下个.y;


	if (x == 0)
	{
		if (y == 1)
		{
			result = 2;
		}
		else
		{
			result = 3;
		}
	}
	else if (y == 0)
	{
		if (x == 1)
		{
			result = 0;
		}
		else
		{
			result = 1;
		}
	}
	return result;
}

地图数据 寻路_地图数据()
{
	地图数据 局_地图数据;
	ULONG64 局_房间数据 = _ReadLong(_ReadLong(_ReadLong(房间编号) + 时间基址) + 门型偏移);
	ULONG64 局_房间索引 = 解密(局_房间数据 + 索引偏移);

	局_地图数据.宽 = _ReadInt(_ReadLong(局_房间数据 + 宽高偏移) + 局_房间索引 * 8 + 0);
	局_地图数据.高 = _ReadInt(_ReadLong(局_房间数据 + 宽高偏移) + 局_房间索引 * 8 + 4);
	局_地图数据.临时变量 = _ReadLong(_ReadLong(局_房间数据 + 数组偏移) + 32 * 局_房间索引 + 8);
	局_地图数据.通道数量 = 局_地图数据.宽 * 局_地图数据.高;
	for (size_t i = 0; i < 局_地图数据.通道数量; i++)
	{
		局_地图数据.地图通道.insert(局_地图数据.地图通道.begin() + i, _ReadInt(局_地图数据.临时变量 + i * 4));
	}
	局_地图数据.起始坐标.x = 取当前房间().x + 1;
	局_地图数据.起始坐标.y = 取当前房间().y + 1;
	局_地图数据.终点坐标.x = 取BOSS房间().x + 1;
	局_地图数据.终点坐标.y = 取BOSS房间().y + 1;
	if (局_地图数据.起始坐标.x == 局_地图数据.终点坐标.x && 局_地图数据.起始坐标.y == 局_地图数据.终点坐标.y)
	{
		return 局_地图数据;
	}
	局_地图数据.消耗疲劳 = 寻路_获取走法(局_地图数据.地图通道, 局_地图数据.宽, 局_地图数据.高, 局_地图数据.起始坐标, 局_地图数据.终点坐标, 局_地图数据.地图走法);
	return 局_地图数据;
}
DWORD 寻路_获取走法(vector<DWORD> 参_地图通道, DWORD 参_宽度, DWORD 参_高度, 坐标型 参_地图起点, 坐标型 参_地图终点, vector<坐标型>& 参_真实走法)
{
	坐标型 start_coordinate;
	坐标型 end_coordinate;
	vector<vector<游戏地图>> map_flag;
	vector<vector<游戏地图>> map_array;
	vector<坐标型> cross_way;

	if (参_地图起点.x == 参_地图终点.x && 参_地图起点.y == 参_地图终点.y)
	{
		参_真实走法.clear();
		参_真实走法.resize(0);
		return 0;
	}
	寻路_生成地图(参_宽度, 参_高度, 参_地图通道, map_array);
	寻路_显示地图(map_array, 参_宽度, 参_高度, map_flag);
	start_coordinate.x = 参_地图起点.x * 3 - 2;
	start_coordinate.y = 参_地图起点.y * 3 - 2;
	end_coordinate.x = 参_地图终点.x * 3 - 2;
	end_coordinate.y = 参_地图终点.y * 3 - 2;
	寻路_路径算法(map_flag, start_coordinate, end_coordinate, 参_宽度 * 3, 参_高度 * 3, cross_way);
	return 寻路_整理坐标(cross_way, 参_真实走法);

}
VOID 寻路_生成地图(DWORD 参_宽度, DWORD 参_高度, vector<DWORD> 参_地图通道, vector<vector<游戏地图>>& 参_游戏地图)
{
	参_游戏地图.clear();
	参_游戏地图.resize(参_宽度);
	for (DWORD x = 0; x < 参_宽度; x++)
	{
		参_游戏地图[x].resize(参_高度);
	}
	int i = 0;
	for (DWORD y = 0; y < 参_高度; y++)
	{
		for (DWORD x = 0; x < 参_宽度; x++)
		{
			参_游戏地图[x][y].地图坐标.x = x;
			参_游戏地图[x][y].地图坐标.y = y;
			参_游戏地图[x][y].地图通道 = 参_地图通道[i];
			参_游戏地图[x][y].地图左边 = 寻路_判断方向(参_地图通道[i], 0);
			参_游戏地图[x][y].地图右边 = 寻路_判断方向(参_地图通道[i], 1);
			参_游戏地图[x][y].地图上边 = 寻路_判断方向(参_地图通道[i], 2);
			参_游戏地图[x][y].地图下边 = 寻路_判断方向(参_地图通道[i], 3);
			参_游戏地图[x][y].背景颜色 = 0xFFFFFF;
			i++;
			if (参_游戏地图[x][y].地图通道 == 0)
				参_游戏地图[x][y].背景颜色 = 0x000000;
		}
	}
}
VOID 寻路_显示地图(vector<vector<游戏地图>> 参_地图数组, DWORD 参_宽度, DWORD 参_高度, vector<vector<游戏地图>>& 参_地图标签)
{
	参_地图标签.clear();
	参_地图标签.resize(参_宽度 * (DWORD64)3);
	for (DWORD x = 0; x < 参_宽度 * 3; x++)
	{
		参_地图标签[x].resize(参_高度 * 3);
	}
	for (DWORD y = 0; y < 参_高度; y++)
	{
		for (DWORD x = 0; x < 参_宽度; x++)
		{
			参_地图标签[(x + (DWORD64)1) * (DWORD64)3 - (DWORD64)2][(y + (DWORD64)1) * (DWORD64)3 - (DWORD64)2].背景颜色 = 0xFFFFFF;
			if (参_地图数组[x][y].地图左边)
				参_地图标签[(x + (DWORD64)1) * (DWORD64)3 - (DWORD64)3][(y + (DWORD64)1) * (DWORD64)3 - (DWORD64)2].背景颜色 = 0xFFFFFF;
			if (参_地图数组[x][y].地图右边)
				参_地图标签[(x + (DWORD64)1) * (DWORD64)3 - (DWORD64)1][(y + (DWORD64)1) * (DWORD64)3 - (DWORD64)2].背景颜色 = 0xFFFFFF;
			if (参_地图数组[x][y].地图上边)
				参_地图标签[(x + (DWORD64)1) * (DWORD64)3 - (DWORD64)2][(y + (DWORD64)1) * (DWORD64)3 - (DWORD64)3].背景颜色 = 0xFFFFFF;
			if (参_地图数组[x][y].地图下边)
				参_地图标签[(x + (DWORD64)1) * (DWORD64)3 - (DWORD64)2][(y + (DWORD64)1) * (DWORD64)3 - (DWORD64)1].背景颜色 = 0xFFFFFF;
		}
	}
}
VOID 寻路_路径算法(vector<vector<游戏地图>> 参_地图标签, 坐标型 参_地图起点, 坐标型 参_地图终点, DWORD 参_宽度, DWORD 参_高度, vector<坐标型>& 参_走法数组)
{
	BOOL 已存在开放列表, 已存在关闭列表;
	坐标型 待检测坐标;
	地图节点 待检测节点, 临时节点;
	vector<地图节点> 开放列表, 关闭列表;
	DWORD 最短编号 = 0;
	DWORD 最小F值, 预测G值;
	DWORD x, y;
	临时节点.当前坐标.x = 参_地图起点.x;
	临时节点.当前坐标.y = 参_地图起点.y;
	参_地图标签[参_地图起点.x][参_地图起点.y].背景颜色 = 0x00FF00;
	参_地图标签[参_地图终点.x][参_地图终点.y].背景颜色 = 0x0000FF;
	开放列表.insert(开放列表.begin(), 临时节点);
	do
	{
		最小F值 = 0;
		for (y = 0; y < 开放列表.size(); y++)
		{
			if (最小F值 == 0)
			{
				最小F值 = 开放列表[0].地图F点;
				最短编号 = y;
			}
			if (开放列表[y].地图F点 < 最小F值)
			{
				最小F值 = 开放列表[y].地图F点;
				最短编号 = y;
			}
		}
		临时节点 = 开放列表[最短编号];
		开放列表.erase(开放列表.begin() + 最短编号);
		关闭列表.insert(关闭列表.begin(), 临时节点);
		if (临时节点.当前坐标.x != 参_地图起点.x || 临时节点.当前坐标.y != 参_地图起点.y)
		{
			if (临时节点.当前坐标.x != 参_地图终点.x || 临时节点.当前坐标.y != 参_地图终点.y)
			{
				参_地图标签[临时节点.当前坐标.x][临时节点.当前坐标.y].背景颜色 = 0x0080FF;
			}
		}
		for (y = 0; y < 关闭列表.size(); y++)
		{
			if (关闭列表[y].当前坐标.x == 参_地图终点.x && 关闭列表[y].当前坐标.y == 参_地图终点.y)
			{
				待检测节点 = 关闭列表[y];
				do
				{
					for (unsigned int x = 0; x < 关闭列表.size(); x++)
					{
						if (关闭列表[x].当前坐标.x == 待检测节点.最终坐标.x && 关闭列表[x].当前坐标.y == 待检测节点.最终坐标.y)
						{
							待检测节点 = 关闭列表[x];
							break;
						}
					}
					if (待检测节点.当前坐标.x != 参_地图起点.x || 待检测节点.当前坐标.y != 参_地图起点.y)
					{
						参_地图标签[待检测节点.当前坐标.x][待检测节点.当前坐标.y].背景颜色 = 0x00D8D8;
						参_走法数组.insert(参_走法数组.begin(), 待检测节点.当前坐标);
					}
				} while (待检测节点.当前坐标.x != 参_地图起点.x || 待检测节点.当前坐标.y != 参_地图起点.y);
				参_走法数组.insert(参_走法数组.begin(), 参_地图起点);
				参_走法数组.insert(参_走法数组.end(), 参_地图终点);
				return;
			}
		}
		for (y = 0; y < 4; y++)
		{
			if (y == 0)
			{
				待检测坐标.x = 临时节点.当前坐标.x;
				待检测坐标.y = 临时节点.当前坐标.y - 1;
			}
			else if (y == 1)
			{
				待检测坐标.x = 临时节点.当前坐标.x - 1;
				待检测坐标.y = 临时节点.当前坐标.y;
			}
			else if (y == 2)
			{
				待检测坐标.x = 临时节点.当前坐标.x + 1;
				待检测坐标.y = 临时节点.当前坐标.y;
			}
			else
			{
				待检测坐标.x = 临时节点.当前坐标.x;
				待检测坐标.y = 临时节点.当前坐标.y + 1;
			}
			if (待检测坐标.x < 0 || 待检测坐标.x >(参_宽度 - 1) || 待检测坐标.y < 0 || 待检测坐标.y >(参_高度 - 1))
				continue;
			if (参_地图标签[待检测坐标.x][待检测坐标.y].背景颜色 == 0x000000)
				continue;
			已存在关闭列表 = false;
			for (x = 0; x < 关闭列表.size(); x++)
			{
				if (关闭列表[x].当前坐标.x == 待检测坐标.x && 关闭列表[x].当前坐标.y == 待检测坐标.y)
				{
					已存在关闭列表 = true;
					break;
				}
			}
			if (已存在关闭列表)
				continue;
			已存在开放列表 = false;
			for (x = 0; x < 开放列表.size(); x++)
			{
				if (开放列表[x].当前坐标.x == 待检测坐标.x && 开放列表[x].当前坐标.y == 待检测坐标.y)
				{
					if (待检测坐标.x != 临时节点.当前坐标.x || 待检测坐标.y != 临时节点.当前坐标.y)
						预测G值 = 14;
					else
						预测G值 = 10;
					if (临时节点.地图G点 + 预测G值 < 开放列表[x].地图G点)
						开放列表[x].最终坐标 = 临时节点.当前坐标;
					已存在开放列表 = true;
					break;
				}
			}
			if (已存在开放列表 == false)
			{
				if (待检测坐标.x == 临时节点.当前坐标.x || 待检测坐标.y == 临时节点.当前坐标.y)
					预测G值 = 10;
				else
					预测G值 = 14;
				待检测节点.地图G点 = 临时节点.地图G点 + 预测G值;
				待检测节点.地图H点 = 参_地图终点.x - 待检测坐标.x * 10 + 参_地图终点.y - 待检测坐标.y * 10;
				待检测节点.地图F点 = 待检测节点.地图G点 + 待检测节点.地图H点;
				待检测节点.当前坐标 = 待检测坐标;
				待检测节点.最终坐标 = 临时节点.当前坐标;
				开放列表.insert(开放列表.begin(), 待检测节点);
			}
		}
	} while (开放列表.size() != 0);
}
DWORD 寻路_整理坐标(vector<坐标型> 参_模拟走法, vector<坐标型>& 参_真实走法)
{
	DWORD x, y;
	DWORD k = 0;
	坐标型 局_临时坐标;
	for (DWORD i = 0; i < 参_模拟走法.size(); i++)
	{
		x = (参_模拟走法[i].x + 2) % 3;
		y = (参_模拟走法[i].y + 2) % 3;
		if (x == 0 && y == 0)
		{
			局_临时坐标.x = (参_模拟走法[i].x + 2) / 3 - 1;
			局_临时坐标.y = (参_模拟走法[i].y + 2) / 3 - 1;
			参_真实走法.insert(参_真实走法.begin() + k, 局_临时坐标);
			k++;
		}
	}
	return(k);
}
BOOL  寻路_判断方向(DWORD 参_通向, DWORD 参_方向)
{
	unsigned char 局_方向数组[4];
	unsigned char 局_方向集合[16][4] = { { 0, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 }, { 0, 1, 1, 0 }, { 1, 0, 0, 0 }, { 1, 1, 0, 0 }, { 1, 0, 1, 0 }, { 1, 1, 1, 0 },
	{ 0, 0, 0, 1 }, { 0, 1, 0, 1 }, { 0, 0, 1, 1 }, { 0, 1, 1, 1 }, { 1, 0, 0, 1 }, { 1, 1, 0, 1 }, { 1, 0, 1, 1 }, { 1, 1, 1, 1 } };
	if (参_通向 >= 0 && 参_通向 <= 15)
		for (int i = 0; i < 4; i++)
			局_方向数组[i] = 局_方向集合[参_通向][i];
	else
		for (int i = 0; i < 4; i++)
			局_方向数组[i] = 0;
	if (局_方向数组[参_方向] == 1)
		return TRUE;
	else
		return FALSE;
}

DWORD 寻路_计算方向(坐标型 参_当前房间, 坐标型 参_下个房间)
{
	DWORD 局_方向 = 0;
	DWORD 局_X, 局_Y;
	局_X = 参_当前房间.x - 参_下个房间.x;
	局_Y = 参_当前房间.y - 参_下个房间.y;
	if (局_X == 0 && 局_Y == 0)
	{
		return 4;
	}

	if (局_X == 0)
	{
		if (局_Y == 1)
		{
			局_方向 = 2;
		}
		else
		{
			局_方向 = 3;
		}
	}
	else if (局_Y == 0)
	{
		if (局_X == 1)
		{
			局_方向 = 0;
		}
		else
		{
			局_方向 = 1;
		}
	}
	return 局_方向;
}

VOID 坐标_顺图(int 顺图方向)
{
	__int64 顺图数据 = 顺图Call(顺图方向);
	__int64 坐标结构 = 顺图数据;

	int 起始横轴 = _ReadInt(坐标结构 + 0);
	int 起始纵轴 = _ReadInt(坐标结构 + 4);
	int 结束横轴 = _ReadInt(坐标结构 + 8);
	int 结束纵轴 = _ReadInt(坐标结构 + 12);

	int 计算横轴 = 0;
	int 计算纵轴 = 0;
	// 0左
	if (顺图方向 == 0)
	{
		计算横轴 = 起始横轴 + 结束横轴 + 20;
		计算纵轴 = 起始纵轴 + 结束纵轴 / 2;
	}
	// 1右
	if (顺图方向 == 1)
	{
		计算横轴 = 起始横轴 - 20;
		计算纵轴 = 起始纵轴 + 结束纵轴 / 2;
	}
	// 2上
	if (顺图方向 == 2)
	{

		计算横轴 = 起始横轴 + 结束横轴 / 2;
		计算纵轴 = 起始纵轴 + 结束纵轴 + 20;
	}
	// 3下
	if (顺图方向 == 3)
	{
		计算横轴 = 起始横轴 + 结束横轴 / 2;
		计算纵轴 = 起始纵轴 - 20;
	}
	if (计算横轴 <= 0 || 计算纵轴 <= 0)
	{
		return;
	}

	坐标Call(计算横轴, 计算纵轴, 0);
	Sleep(20);
	坐标Call(起始横轴 + 结束横轴 / 2, 起始纵轴, 0);
}


VOID 组包_顺图(int 方向ID)
{

	if (取是否城镇() == true) {
		return;
	}

	if (取是否开门() == false){
		return;
	}

	坐标型	当前房间 = 取当前房间();
	if (方向ID == 0)
	{
		组包过图(当前房间.x - 1, 当前房间.y);
	}
	if (方向ID == 1)
	{
		组包过图(当前房间.x + 1, 当前房间.y);
	}

	if (方向ID == 2)
	{
		组包过图(当前房间.x, 当前房间.y - 1);
	}
	if (方向ID == 3)
	{
		组包过图(当前房间.x, 当前房间.y + 1);
	}
}

VOID 组包_下() 
{
	坐标型 当前房间 = 取当前房间();
	组包过图(当前房间.x, 当前房间.y + 1);
}

VOID 组包_左() 
{
	坐标型 当前房间 = 取当前房间();
	组包过图(当前房间.x - 1, 当前房间.y);
}

VOID 组包_右() 
{
	坐标型 当前房间 = 取当前房间();
	组包过图(当前房间.x + 1, 当前房间.y);
}