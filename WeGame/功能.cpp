#include "pch.h"
#include "公告.h"

#include "公用.h"
#include "读写.h"
#include "游戏Call.h"
#include "公告.h"
#include "遍历.h"
#include "引用.h"
#include "加密.h"
#include "数组.h"
#include "配置.h"
#include "组包.h"
#include "判断.h"
#include "文件.h"

HANDLE 技能开关句柄;

ULONG64 路径Call(int 编号)
{
	return Func_CALL(路径CALL, 目录基址, 编号);
}


ULONG64 加载Call(ULONG64 路径文本)
{
	ULONG64 空白地址[100] = { NULL };
	ULONG64 rdi = Func_CALL(加载CALL, *(ULONG64*)副本信息, 路径文本, 1);
	if (rdi > 0)
	{
		ULONG64 r8 = Func_CALL(分割CALL_1, (ULONG64)空白地址, (rdi + Atk改伤_1));
		ULONG64 rax = Func_CALL(分割CALL_2, (ULONG64)空白地址, (rdi + Atk改伤_2), r8);

		return Func_CALL(加载CALL, *(ULONG64*)路径基址, *(ULONG64*)rax, 1);
	}
	return 0;
}

void 技能伤害(int 代码, int 伤害)
{
	if (代码 == 11520 ||
		代码 == 39002 ||
		代码 == 54141 ||
		代码 == 70119 ||
		代码 == 11305 ||
		代码 == 14098 ||
		代码 == 11431 ||
		代码 == 11506 ||
		代码 == 70032 ||
		代码 == 54106 ||
		代码 == 61057 ||
		代码 == 56609 ||
		代码 == 100010 ||
		代码 == 109004795 ||
		代码 == 62129 ||
		代码 == 109004747 ||
		代码 == 0 ||
		伤害 == 0)
	{
		return;
	}
	else {
		ULONG64 文本指针 = 路径Call(代码);
		if (文本指针 > 0)
		{
			ULONG64 目录指针 = 加载Call(文本指针);
			if (文本指针 > 0 && 目录指针 > 0)
			{
				超级加密(目录指针 + 32, 伤害);
			}
		}
	}
}


VOID 技能开关() {
	static bool _switch;
	_switch = !_switch;

	if (_switch == true)
	{
		技能开关句柄 = _CreateThread(&全屏技能);
		游戏公告("技能全屏 - 开启", 2);
	}
	else
	{
		_DeleteThread(技能开关句柄);
		游戏公告("技能全屏 - 关闭", 2);
	}
}

VOID 无形秒杀()
{
	技能Call(0, 39002, 0, 0, 0, 0, 0);
	游戏公告("无形秒杀 - 完毕", 2);
}

VOID 武器冰冻() {
	static bool _switch;
	__int64 static 局_空白地址;
	if (局_空白地址 == 0)
	{
		局_空白地址 = (__int64)_ApplyMemory(1024);
	}
	__int64 空白地址 = 局_空白地址;
	int 冰冻伤害 = 99999;
	_switch = !_switch;
	if (_switch == true)
	{
		_WriteInt(空白地址, 0);
		_WriteInt(空白地址 + 4, 2000);
		_WriteInt(空白地址 + 8, 2000);
		_WriteInt(空白地址 + 12, 50);
		_WriteInt(空白地址 + 16, 100);
		_WriteInt(空白地址 + 20, 99);
		_WriteInt(空白地址 + 24, 130);
		_WriteInt(空白地址 + 28, 冰冻伤害 * 100000);
		__int64 武器 = _ReadLong(_ReadLong(取人物基质()) + 武器偏移);
		_WriteLong(武器 + 冰冻开始, 空白地址);
		_WriteLong(武器 + 冰冻结束, 空白地址 + 32);
		游戏公告("武器冰冻 - 启动", 2);
	}
	else
	{
		__int64 武器 = _ReadLong(_ReadLong(取人物基质()) + 武器偏移);
		_WriteLong(武器 + 冰冻开始, 0);
		_WriteLong(武器 + 冰冻结束, 0);

		for (int i = 0; i <= 7; i++)
		{
			_WriteLong(空白地址, 0);
			空白地址 = 空白地址 + 4;
		}
		游戏公告("武器冰冻 - 关闭", 2);
	}
}

VOID HOOK伤害() {
	static bool _switch;
	__int64 倍攻伤害 = 9999999;
	static ByteArr 地址原数据;
	_switch = !_switch;
	if (_switch == true)
	{
		地址原数据 = _ReadByteArr(全局基址, 10);
		ByteArr data = _AppendToBytes(ByteArr{ 72, 190 }, _IntToBytes(倍攻伤害, 8));
		_WriteByteArr(全局基址, data);
		游戏公告("HOOK伤害 - 启动", 2);
	}
	else
	{
		_WriteByteArr(全局基址, 地址原数据);
		游戏公告("HOOK伤害 - 关闭", 2);
	}
}



void 跟随遍历()
{
	if (*(ULONG*)游戏状态 != 3)
	{
		return;
	}
	遍历数据 跟随;
	跟随.人物指针 = *(ULONG64*)人物基址;
	跟随.地图指针 = *(ULONG64*)(跟随.人物指针 + 地图偏移 + 16);
	跟随.首地址 = *(ULONG64*)(跟随.地图指针 + 地图开始2);
	跟随.尾地址 = *(ULONG64*)(跟随.地图指针 + 地图结束2);
	跟随.遍历数量 = (ULONG)((跟随.尾地址 - 跟随.首地址) / 32);
	for (跟随.遍历次数 = NULL; 跟随.遍历次数 < 跟随.遍历数量; 跟随.遍历次数++)
	{
		跟随.遍历指针 = *(ULONG64*)(跟随.首地址 + 跟随.遍历次数 * 32 + 16 - 32);
		跟随.遍历类型 = *(ULONG*)(跟随.遍历指针 + 类型偏移);
		跟随.遍历代码 = *(ULONG*)(跟随.遍历指针 + 代码偏移);
		跟随.遍历名称 = (wchar_t*)*(ULONG64*)(跟随.遍历指针 + 名称偏移);
		if (跟随.遍历类型 == 529 || 跟随.遍历类型 == 273 || 跟随.遍历类型 == 545)
		{
			跟随.遍历阵营 = *(ULONG*)(跟随.遍历指针 + 阵营偏移);
			跟随.遍历血量 = *(ULONG64*)(跟随.遍历指针 + 怪物血量);
			if (跟随.遍历阵营 != 0 && 跟随.遍历血量 >= 0)
			{
				if (读配置(配置.跟随方式) == 1)
				{
					坐标Call(取坐标Call(跟随.遍历指针, 0), 取坐标Call(跟随.遍历指针, 1), 0);
				}
				if (读配置(配置.跟随方式) == 2)
				{
					漂移Call(取坐标Call(跟随.遍历指针, 0), 取坐标Call(跟随.遍历指针, 1), 0, 1);
				}


				break;
			}
		}
	}
}



void 拾取遍历()
{
	if (*(ULONG*)游戏状态 != 3)
	{
		return;
	}
	ULONG64 人物指针, 地图指针, 首, 尾, 遍历指针, 物品指针, 物品代码;
	int 遍历数量, 遍历类型, 遍历阵营, 遍历次数, 物品数量;
	坐标型 遍历位置;
	wstring 物品名称;
	vector<坐标型> 物品位置;
	物品位置.clear();
	人物指针 = *(ULONG64*)人物基址;
	地图指针 = *(ULONG64*)(人物指针 + 地图偏移);
	首 = *(ULONG64*)(地图指针 + 地图开始2);
	尾 = *(ULONG64*)(地图指针 + 地图结束2);
	遍历数量 = (int)((尾 - 首) / 8);
	for (遍历次数 = NULL; 遍历次数 < 遍历数量; 遍历次数++)
	{
		遍历指针 = *(ULONG64*)(首 + 遍历次数 * 8);
		遍历类型 = *(ULONG*)(遍历指针 + 类型偏移);
		遍历阵营 = *(ULONG*)(遍历指针 + 阵营偏移);
		if (遍历阵营 == 200 && 遍历类型 == 289)
		{
			物品指针 = *(ULONG64*)(遍历指针 + 地面物品);
			物品名称 = (wchar_t*)*(ULONG64*)(物品指针 + 装备名称);
			if (判断_过滤拾取(物品名称))
			{
				continue;
			}
			物品数量 = 超级解密(物品指针 + 数量偏移);
			物品代码 = *(ULONG*)(物品指针 + 装备代码);
			遍历位置 = 读取类型坐标(遍历指针);
			if (物品代码 != 0)
			{
				if (读配置(配置.拾取方式) == 2)
				{
					*(ULONG*)(物品指针 + 装备代码) = 10092844;
				}
			}
			物品位置.push_back(遍历位置);
		}
	}
	if (物品位置.size() > 0)
	{
		for (遍历次数 = NULL; 遍历次数 < 物品位置.size(); ++遍历次数)
		{
			if (读配置(配置.跟随方式) == 1)
			{
				坐标Call(物品位置.at(遍历次数).x, 物品位置.at(遍历次数).y, 0);
			}
			if (读配置(配置.跟随方式) == 2)
			{
				漂移Call(物品位置.at(遍历次数).x, 物品位置.at(遍历次数).y, 0, 1);
			}
			if (读配置(配置.拾取方式) == 1)
			{

			}
		}
	}
}



void 处理装备()
{
	背包遍历 背包;
	背包.背包地址 = *(ULONG64*)背包基址;
	背包.首地址 = *(ULONG64*)(背包.背包地址 + 背包指针偏移) + 288;
	for (背包.物品次数 = 0; 背包.物品次数 < 56; 背包.物品次数++)
	{
		背包.装备指针 = *(ULONG64*)(背包.首地址 + 背包.物品次数 * 8);
		if (背包.装备指针 != 0)
		{
			背包.装备属性 = *(ULONG*)(背包.装备指针 + 装备品级);
			背包.装备代码 = *(ULONG*)(背包.装备指针 + 装备代码);
			背包.装备名称 = (wchar_t*)*(ULONG64*)(背包.装备指针 + 装备名称);
			if (背包.装备属性 == 0)
			{
				if (读配置(配置.白色装备) == 1)
				{
					组包卖物(背包.物品次数 + 9);
				}
				if (读配置(配置.白色装备) == 2)
				{
					组包分解(背包.物品次数 + 9);
				}
				if (读配置(配置.白色装备) == 3)
				{
					//组包_丢弃物品(背包.物品次数 + 9, 背包.装备代码);
				}
				背包.白色件数++;
			}
			if (背包.装备属性 == 1)
			{
				if (读配置(配置.蓝色装备) == 1)
				{
					组包卖物(背包.物品次数 + 9);
				}
				if (读配置(配置.蓝色装备) == 2)
				{
					组包分解(背包.物品次数 + 9);
				}
				if (读配置(配置.蓝色装备) == 3)
				{
					//组包_丢弃物品(背包.物品次数 + 9, 背包.装备代码);
				}
				背包.蓝色件数++;
			}
			if (背包.装备属性 == 2)
			{
				if (读配置(配置.紫色装备) == 1)
				{
					组包卖物(背包.物品次数 + 9);
				}
				if (读配置(配置.紫色装备) == 2)
				{
					组包分解(背包.物品次数 + 9);
				}
				if (读配置(配置.紫色装备) == 3)
				{
					//组包_丢弃物品(背包.物品次数 + 9, 背包.装备代码);
				}
				背包.紫色件数++;
			}
			if (背包.装备属性 == 3)
			{
				if (读配置(配置.粉色装备) == 1)
				{
					组包卖物(背包.物品次数 + 9);
				}
				if (读配置(配置.粉色装备) == 2)
				{
					组包分解(背包.物品次数 + 9);
				}
				if (读配置(配置.粉色装备) == 3)
				{
					//组包_丢弃物品(背包.物品次数 + 9, 背包.装备代码);
				}
				背包.粉色件数++;
			}
			if (背包.装备属性 == 4)
			{
				if (读配置(配置.史诗装备) == 1)
				{
					组包卖物(背包.物品次数 + 9);
				}
				if (读配置(配置.史诗装备) == 2)
				{
					组包分解(背包.物品次数 + 9);
				}
				if (读配置(配置.史诗装备) == 3)
				{
					//组包_丢弃物品(背包.物品次数 + 9, 背包.装备代码);
				}
				背包.史诗件数++;
			}
			if (背包.装备属性 == 5)
			{
				if (读配置(配置.勇者装备) == 1)
				{
					组包卖物(背包.物品次数 + 9);
				}
				if (读配置(配置.勇者装备) == 2)
				{
					组包分解(背包.物品次数 + 9);
				}
				if (读配置(配置.勇者装备) == 3)
				{
					//组包_丢弃物品(背包.物品次数 + 9, 背包.装备代码);
				}
				背包.勇者件数++;
			}
			if (背包.装备属性 == 6)
			{
				if (读配置(配置.传说装备) == 1)
				{
					组包卖物(背包.物品次数 + 9);
				}
				if (读配置(配置.传说装备) == 2)
				{
					组包分解(背包.物品次数 + 9);
				}
				if (读配置(配置.传说装备) == 3)
				{
					//组包_丢弃物品(背包.物品次数 + 9, 背包.装备代码);
				}
				背包.传说件数++;
			}
		}
	}
	if (背包.白色件数 > 0)神话公告(L"{ 处理 -> 白装 ( " + 到文本(背包.白色件数) + L" ) }件", 1);
	if (背包.蓝色件数 > 0)神话公告(L"{ 处理 -> 蓝装 ( " + 到文本(背包.蓝色件数) + L" ) }件", 1);
	if (背包.紫色件数 > 0)神话公告(L"{ 处理 -> 紫装 ( " + 到文本(背包.紫色件数) + L" ) }件", 1);
	if (背包.粉色件数 > 0)神话公告(L"{ 处理 -> 粉装 ( " + 到文本(背包.粉色件数) + L" ) }件", 1);
	if (背包.史诗件数 > 0)神话公告(L"{ 处理 -> 史诗 ( " + 到文本(背包.史诗件数) + L" ) }件", 1);
	if (背包.勇者件数 > 0)神话公告(L"{ 处理 -> 勇者 ( " + 到文本(背包.勇者件数) + L" ) }件", 1);
	if (背包.传说件数 > 0)神话公告(L"{ 处理 -> 传说 ( " + 到文本(背包.传说件数) + L" ) }件", 1);
}

void 全屏遍历()
{
	if (*(ULONG*)游戏状态 != 3)
	{
		return;
	}
	遍历数据 全屏;
	全屏.人物指针 = *(ULONG64*)人物基址;
	全屏.地图指针 = *(ULONG64*)(全屏.人物指针 + 地图偏移);
	全屏.首地址 = *(ULONG64*)(全屏.地图指针 + 地图开始2);
	全屏.尾地址 = *(ULONG64*)(全屏.地图指针 + 地图结束2);
	全屏.遍历数量 = (ULONG)((全屏.尾地址 - 全屏.首地址) / 8);
	for (全屏.遍历次数 = NULL; 全屏.遍历次数 < 全屏.遍历数量; 全屏.遍历次数++)
	{
		全屏.遍历指针 = *(ULONG64*)(全屏.首地址 + 全屏.遍历次数 * 8);
		全屏.遍历类型 = *(ULONG*)(全屏.遍历指针 + 类型偏移);
		全屏.遍历代码 = *(ULONG*)(全屏.遍历指针 + 代码偏移);
		全屏.遍历名称 = (wchar_t*)*(ULONG64*)(全屏.遍历指针 + 名称偏移);
		if (全屏.遍历类型 == 529 || 全屏.遍历类型 == 273 || 全屏.遍历类型 == 545)
		{
			全屏.遍历阵营 = *(ULONG*)(全屏.遍历指针 + 阵营偏移);
			全屏.遍历血量 = *(ULONG64*)(全屏.遍历指针 + 怪物血量);
			if (全屏.遍历阵营 != 0 && 全屏.遍历血量 != 0)
			{
				技能伤害(读配置(配置.技能代码), 读配置(配置.技能伤害));

				技能Call(全屏.人物指针, 读配置(配置.技能代码), 0, 取坐标Call(全屏.遍历指针, 0), 取坐标Call(全屏.遍历指针, 1), 取坐标Call(全屏.遍历指针, 2), (FLOAT)读配置(配置.技能大小));

				++全屏.技能个数;
				if (全屏.技能个数 >= 读配置(配置.技能个数)) break;
			}
		}
	}
}



void 全屏开关()
{
	全局.技能开关 = !全局.技能开关;
	if (全局.技能开关)
	{
		SetTimer(收包.游戏句柄, 1001, 读配置(配置.技能频率), (TIMERPROC)全屏遍历);
		神话公告(L"{ 技能全屏 -> Open }", 1);
	}
	else
	{
		KillTimer(收包.游戏句柄, 1001);
		神话公告(L"{ 技能全屏 -> Close }", 1);

	}
}