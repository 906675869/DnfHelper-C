#include "pch.h"
#include "文件.h"
#include "Address.h"
#include "数组.h"
#include "加密.h"
#include "游戏CALL.h"
#include "公告.h"
#include "引用.h"
#include "组包.h"
#include "判断.h"


任务结构 任务;

bool 跳过数据()
{

	任务.任务地址 = *(ULONG64*)任务基址;
	任务.首地址 = *(ULONG64*)(任务.任务地址 + 全部任务首地址);
	任务.尾地址 = *(ULONG64*)(任务.任务地址 + 全部任务尾地址);
	任务.任务数量 = (int)((任务.尾地址 - 任务.首地址) / 8);
	for (任务.任务次数 = NULL; 任务.任务次数 < 任务.任务数量; 任务.任务次数++)
	{
		任务.任务指针 = *(ULONG64*)(任务.首地址 + 任务.任务次数 * 8);
		任务.任务类型 = *(ULONG*)(任务.任务指针 + 任务类型);
		if (任务.任务类型 == NULL)
		{
			任务.任务等级 = *(ULONG*)(任务.任务指针 + 任务等级);
			if (任务.任务等级 < *(ULONG*)角色等级)
			{
				return true;
			}

		}
	}
	return false;
}

bool 是否有主线任务()
{

	任务.任务地址 = *(ULONG64*)任务基址;
	任务.首地址 = *(ULONG64*)(任务.任务地址 + 全部任务首地址);
	任务.尾地址 = *(ULONG64*)(任务.任务地址 + 全部任务尾地址);
	任务.任务数量 = (int)((任务.尾地址 - 任务.首地址) / 8);
	for (任务.任务次数 = NULL; 任务.任务次数 < 任务.任务数量; 任务.任务次数++)
	{
		任务.任务指针 = *(ULONG64*)(任务.首地址 + 任务.任务次数 * 8);
		任务.任务类型 = *(ULONG*)(任务.任务指针 + 任务类型);
		if (任务.任务类型 == NULL)
		{
			return true;
		}
	}
	return false;
}

int 返回主线()
{
	任务.任务地址 = *(ULONG64*)任务基址;
	任务.首地址 = *(ULONG64*)(任务.任务地址 + 全部任务首地址);
	任务.尾地址 = *(ULONG64*)(任务.任务地址 + 全部任务尾地址);
	任务.任务数量 = (int)((任务.尾地址 - 任务.首地址) / 8);
	for (任务.任务次数 = NULL; 任务.任务次数 < 任务.任务数量; 任务.任务次数++)
	{
		任务.任务指针 = *(ULONG64*)(任务.首地址 + 任务.任务次数 * 8);
		任务.局部编号 = *(ULONG*)(任务.任务指针);
		任务.任务类型 = *(ULONG*)(任务.任务指针 + 任务类型);
		if (任务.任务类型 == NULL)
		{
			return 任务.局部编号;

			任务.任务长度 = *(ULONG*)(任务.任务指针 + 40);
			if (任务.任务长度 > 7)
			{
				任务.任务名称 = (wchar_t*)*(ULONG64*)(任务.任务指针 + 16);
			}
			else {
				任务.任务名称 = (wchar_t*)(任务.任务指针 + 16);
			}
			任务.任务条件 = (wchar_t*)*(ULONG64*)(任务.任务指针 + 任务条件);

		}
	}
	return -1;
}

int 返回隐藏()
{
	任务.任务地址 = *(ULONG64*)任务基址;
	任务.首地址 = *(ULONG64*)(任务.任务地址 + 已接任务首地址);
	任务.尾地址 = *(ULONG64*)(任务.任务地址 + 已接任务尾地址);
	任务.任务数量 = (int)((任务.尾地址 - 任务.首地址) / 16);
	for (任务.任务次数 = NULL; 任务.任务次数 < 任务.任务数量; 任务.任务次数++)
	{
		任务.任务指针 = *(ULONG64*)(任务.首地址 + 任务.任务次数 * 16);
		任务.局部编号 = *(ULONG*)(任务.任务指针);
		任务.任务类型 = *(ULONG*)(任务.任务指针 + 任务类型);
		if (任务.任务类型 == 11)
		{
			return 任务.局部编号;
		}
	}
	return -1;
}

int 自动排序(const void* a, const void* b)
{
	return *(ULONG*)b - *(ULONG*)a;
}

int 完成次数(int 解密次数)
{
	int 次数数组[3], 剩余次数;

	if (解密次数 < 512)
		return 解密次数;
	if (解密次数 == 512)
		return 1;
	次数数组[0] = 解密次数 % 512;
	剩余次数 = 解密次数 - 次数数组[0];
	if (剩余次数 < 262144)
		次数数组[1] = 剩余次数 / 512;
	else
		次数数组[1] = (剩余次数 % 262144) / 512;
	剩余次数 = 剩余次数 - 次数数组[0] * 512;
	if (剩余次数 < 262144)
		次数数组[2] = 0;
	次数数组[2] = 剩余次数 / 262144;
	qsort(次数数组, 3, sizeof(次数数组[0]), 自动排序);

	if (次数数组[0] == 0)
		次数数组[0] = 1;
	return 次数数组[0];
}

int 任务次数(int 任务编号)
{
	任务.任务地址 = *(ULONG64*)任务基址;
	任务.首地址 = *(ULONG64*)(任务.任务地址 + 已接任务首地址);
	任务.尾地址 = *(ULONG64*)(任务.任务地址 + 已接任务尾地址);
	任务.任务数量 = (int)((任务.尾地址 - 任务.首地址) / 16);
	for (任务.任务次数 = NULL; 任务.任务次数 < 任务.任务数量; 任务.任务次数++)
	{
		任务.任务指针 = *(ULONG64*)(任务.首地址 + 任务.任务次数 * 16);
		任务.局部编号 = *(ULONG*)(任务.任务指针);
		if (任务.局部编号 == 任务编号)
		{
			return 超级解密(任务.首地址 + 任务.任务次数 * 16 + 8);
		}
	}
	return -1;
}

int 获取任务地图(int 任务编号)
{

	任务.任务地址 = *(ULONG64*)任务基址;
	任务.首地址 = *(ULONG64*)(任务.任务地址 + 已接任务首地址);
	任务.尾地址 = *(ULONG64*)(任务.任务地址 + 已接任务尾地址);
	任务.任务数量 = (int)((任务.尾地址 - 任务.首地址) / 16);
	for (任务.任务次数 = NULL; 任务.任务次数 < 任务.任务数量; 任务.任务次数++)
	{
		任务.任务指针 = *(ULONG64*)(任务.首地址 + 任务.任务次数 * 16);

		if (*(ULONG*)任务.任务指针 == 任务编号)
		{
			ULONG64 编号地址 = *(ULONG64*)(任务.任务指针 + 任务副本);

			return *(ULONG*)编号地址;
		}
	}
	return 0;
}

int 任务是否完成(int 对象编号) /*已完成*/
{

	任务.任务地址 = *(ULONG64*)任务基址;
	任务.首地址 = *(ULONG64*)(任务.任务地址 + 已接任务首地址);
	任务.尾地址 = *(ULONG64*)(任务.任务地址 + 已接任务尾地址);
	任务.任务数量 = (int)((任务.尾地址 - 任务.首地址) / 16);
	for (任务.任务次数 = NULL; 任务.任务次数 < 任务.任务数量; 任务.任务次数++)
	{
		任务.任务指针 = *(ULONG64*)(任务.首地址 + 任务.任务次数 * 16);
		任务.局部编号 = *(ULONG*)(任务.任务指针);
		if (任务.局部编号 == 对象编号)
		{
			任务.局部解密 = 超级解密(任务.首地址 + 任务.任务次数 * 16 + 8);
			if (任务.局部解密 > 0)
			{
				return 1;
			}
			else if (任务.局部解密 == 0)
			{
				return 2;
			}
		}
	}
	return 0;
}

int 获取处理方式(int 对象编号)
{
	任务.任务地址 = *(ULONG64*)任务基址;
	任务.首地址 = *(ULONG64*)(任务.任务地址 + 已接任务首地址);
	任务.尾地址 = *(ULONG64*)(任务.任务地址 + 已接任务尾地址);
	任务.任务数量 = (int)((任务.尾地址 - 任务.首地址) / 16);
	for (任务.任务次数 = NULL; 任务.任务次数 < 任务.任务数量; 任务.任务次数++)
	{
		任务.任务指针 = *(ULONG64*)(任务.首地址 + 任务.任务次数 * 16);
		if (*(ULONG*)任务.任务指针 == 对象编号)
		{
			任务.任务条件 = (wchar_t*)*(ULONG64*)(任务.任务指针 + 任务条件);

			if (wcsstr(任务.任务条件, TEXT("[quest clear]")) != NULL || wcsstr(任务.任务条件, TEXT("[question]")) != NULL)
			{
				return 3;
			}
			if (wcsstr(任务.任务条件, TEXT("[seeking]")) != NULL)
			{
				if (任务是否完成(对象编号) == 2)
				{
					提交Call(对象编号);
					return -1;
				}
				if (获取任务地图(对象编号) > 0)
				{
					return 2;
				}
				else
				{
					return 3;
				}
			}
			if (
				wcsstr(任务.任务条件, TEXT("[meet npc]")) != NULL ||
				wcsstr(任务.任务条件, TEXT("[seek n meet npc]")) != NULL ||
				wcsstr(任务.任务条件, TEXT("[reach the range]")) != NULL ||
				wcsstr(任务.任务条件, TEXT("[look cinematic]")) != NULL
				)
			{
				return 1;
			}

			if (
				wcsstr(任务.任务条件, TEXT("[hunt monster]")) != NULL ||
				wcsstr(任务.任务条件, TEXT("[condition under clear]")) != NULL ||
				wcsstr(任务.任务条件, TEXT("[clear map]")) != NULL ||
				wcsstr(任务.任务条件, TEXT("[hunt enemy]")) != NULL
				)
			{
				return 2;
			}

		}
	}
	return -1;
}

bool 获取处理结果(int 对象编号)
{
	int 完成状态, 处理方式;
	完成状态 = 完成次数(任务次数(对象编号));
	处理方式 = 获取处理方式(对象编号);
	神话公告(L"任务编号: " + 到文本(对象编号), 1);
	神话公告(L"处理方式: " + 到文本(处理方式), 1);
	if (完成状态 == -1)
	{
		接受Call(对象编号);
	}
	if (完成状态 == 0)
	{
		提交Call(对象编号);
	}
	if (处理方式 == 1)
	{
		完成Call(对象编号, 完成状态);
	}
	if (处理方式 == 2)
	{
		全局.任务编号 = 对象编号;
		全局.副本编号 = 获取任务地图(对象编号);
		神话公告(L"剧情任务地图编号：" + 到文本(全局.副本编号), 1);
		全局.副本难度 = 0;
		return true;
	}
	if (处理方式 == 3)
	{
		if (跳过数据() == true)
		{
			神话公告(L"剧情任务正在跳过任务", 1);
			组包跳过();
		}
		else
		{
			全局.副本编号 = 等级地图();
			全局.副本难度 = 难度Call(全局.副本编号);
			return true;
		}
	}
	return false;
}